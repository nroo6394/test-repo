name: Automated Release

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master
  workflow_dispatch:

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  release:
    runs-on: ubuntu-latest
    if: "!contains(github.event.head_commit.message, '[skip ci]')"
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Configure semantic-release
        run: |
          cat > .releaserc.json << 'EOF'
          {
            "branches": [
              "master"
            ],
            "plugins": [
              [
                "@semantic-release/commit-analyzer",
                {
                  "preset": "conventionalcommits",
                  "releaseRules": [
                    { "type": "feat", "release": "minor" },
                    { "type": "fix", "release": "patch" },
                    { "type": "perf", "release": "patch" },
                    { "type": "revert", "release": "patch" },
                    { "type": "docs", "release": "patch" },
                    { "type": "refactor", "release": false },
                    { "type": "test", "release": false },
                    { "type": "build", "release": false },
                    { "type": "ci", "release": false },
                    { "type": "chore", "release": false },
                    { "type": "style", "release": false },
                    { "breaking": true, "release": "major" }
                  ]
                }
              ],
              [
                "@semantic-release/release-notes-generator",
                {
                  "preset": "conventionalcommits",
                  "presetConfig": {
                    "types": [
                      { "type": "feat", "section": "Features" },
                      { "type": "fix", "section": "Bug Fixes" },
                      { "type": "perf", "section": "Performance Improvements" },
                      { "type": "revert", "section": "Reverts" },
                      { "type": "docs", "section": "Documentation" },
                      { "type": "refactor", "section": "Code Refactoring", "hidden": true },
                      { "type": "test", "section": "Tests", "hidden": true },
                      { "type": "build", "section": "Build System", "hidden": true },
                      { "type": "ci", "section": "CI/CD", "hidden": true },
                      { "type": "chore", "section": "Chores", "hidden": true },
                      { "type": "style", "section": "Styles", "hidden": true }
                    ]
                  }
                }
              ],
              [
                "@semantic-release/github",
                {
                  "successComment": false,
                  "failComment": false,
                  "releasedLabels": false
                }
              ]
            ]
          }
          EOF

      - name: Install semantic-release dependencies
        run: |
          npm install --no-save \
            semantic-release@^24.0.0 \
            @semantic-release/github@^11.0.0 \
            @semantic-release/commit-analyzer@^13.0.0 \
            @semantic-release/release-notes-generator@^14.0.0 \
            conventional-changelog-conventionalcommits@^8.0.0

      - name: Validate conventional commits (PR only)
        if: github.event_name == 'pull_request'
        run: |
          echo "üîç Validating conventional commits in PR..."
          echo ""
          
          # Get the base branch commit hash
          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"
          
          echo "Base SHA: $BASE_SHA"
          echo "Head SHA: $HEAD_SHA"
          echo ""
          
          # Get all commits in the PR (excluding merge commits)
          PR_COMMITS=$(git log --no-merges --pretty=format:"%H|%s" "$BASE_SHA..$HEAD_SHA")
          
          if [ -z "$PR_COMMITS" ]; then
            echo "‚ùå No commits found in this PR"
            exit 1
          fi
          
          echo "Commits in this PR:"
          echo "$PR_COMMITS" | while IFS='|' read -r commit_hash commit_message; do
            echo "  $(echo $commit_hash | cut -c1-8): $commit_message"
          done
          echo ""
          
          # Validate each commit message against conventional commit format
          VALID_COMMITS=0
          TOTAL_COMMITS=0
          INVALID_COMMITS=""
          RELEASE_TYPE="none"
          
          echo "$PR_COMMITS" | while IFS='|' read -r commit_hash commit_message; do
            TOTAL_COMMITS=$((TOTAL_COMMITS + 1))
            short_hash=$(echo $commit_hash | cut -c1-8)
            
            # Check if commit message follows conventional commit format
            if echo "$commit_message" | grep -qE '^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\(.+\))?!?:\s.+'; then
              echo "‚úÖ Valid: $short_hash - $commit_message"
              VALID_COMMITS=$((VALID_COMMITS + 1))
              
              # Determine release type (highest priority wins)
              if echo "$commit_message" | grep -qE '!:\s'; then
                # Breaking change
                RELEASE_TYPE="major"
              elif echo "$commit_message" | grep -qE '^feat(\(.+\))?:\s' && [ "$RELEASE_TYPE" != "major" ]; then
                # New feature
                RELEASE_TYPE="minor"
              elif echo "$commit_message" | grep -qE '^(fix|perf|revert|docs)(\(.+\))?:\s' && [ "$RELEASE_TYPE" = "none" ]; then
                # Bug fix, performance, revert, or docs
                RELEASE_TYPE="patch"
              fi
            else
              echo "‚ùå Invalid: $short_hash - $commit_message"
              INVALID_COMMITS="$INVALID_COMMITS\n  - $short_hash: $commit_message"
            fi
          done
          
          # Export results for the next step
          echo "TOTAL_COMMITS=$(echo "$PR_COMMITS" | wc -l)" >> $GITHUB_ENV
          echo "VALID_COMMITS=$VALID_COMMITS" >> $GITHUB_ENV
          echo "RELEASE_TYPE=$RELEASE_TYPE" >> $GITHUB_ENV
          
          # Store invalid commits in a file for later use
          if [ ! -z "$INVALID_COMMITS" ]; then
            echo -e "$INVALID_COMMITS" > invalid_commits.txt
          fi

      - name: Predict release version (PR only)
        if: github.event_name == 'pull_request'
        run: |
          echo ""
          echo "üîÆ Release Prediction Analysis..."
          echo ""
          
          # Get the latest tag/version from the repository
          CURRENT_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Current version: $CURRENT_VERSION"
          echo "Release type determined: $RELEASE_TYPE"
          echo ""
          
          # Calculate next version based on release type
          if [ "$RELEASE_TYPE" = "none" ]; then
            NEXT_VERSION="No release"
            RELEASE_EXPLANATION="‚ùå No release - only non-releasing commits (refactor, test, build, ci, chore, style)"
          else
            # Extract version numbers (remove 'v' prefix if present)
            VERSION_NUMBER=$(echo $CURRENT_VERSION | sed 's/^v//')
            
            # Parse version components
            if echo "$VERSION_NUMBER" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+'; then
              MAJOR=$(echo $VERSION_NUMBER | cut -d. -f1)
              MINOR=$(echo $VERSION_NUMBER | cut -d. -f2)
              PATCH=$(echo $VERSION_NUMBER | cut -d. -f3)
            else
              # Default to 0.0.0 if no valid version found
              MAJOR=0
              MINOR=0
              PATCH=0
            fi
            
            # Calculate next version
            case $RELEASE_TYPE in
              "major")
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                NEXT_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
                RELEASE_EXPLANATION="üöÄ Major release - breaking changes detected"
                ;;
              "minor")
                MINOR=$((MINOR + 1))
                PATCH=0
                NEXT_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
                RELEASE_EXPLANATION="‚ú® Minor release - new features added"
                ;;
              "patch")
                PATCH=$((PATCH + 1))
                NEXT_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
                RELEASE_EXPLANATION="üîß Patch release - bug fixes or improvements"
                ;;
            esac
          fi
          
          # Export for next step
          echo "NEXT_VERSION=$NEXT_VERSION" >> $GITHUB_ENV
          echo "RELEASE_EXPLANATION=$RELEASE_EXPLANATION" >> $GITHUB_ENV

      - name: Check validation results (PR only)
        if: github.event_name == 'pull_request'
        run: |
          echo ""
          echo "üìä Validation Results:"
          echo "  Total commits: $TOTAL_COMMITS"
          echo "  Valid conventional commits: $VALID_COMMITS"
          echo "  Invalid commits: $((TOTAL_COMMITS - VALID_COMMITS))"
          echo ""
          
          if [ "$VALID_COMMITS" -eq 0 ]; then
            echo "‚ùå PR VALIDATION FAILED"
            echo ""
            echo "None of the commits in this PR follow conventional commit format."
            echo ""
            echo "Invalid commits:"
            if [ -f invalid_commits.txt ]; then
              cat invalid_commits.txt
            fi
            echo ""
            echo "üìã Conventional Commit Format Required:"
            echo "   feat: description     ‚Üí Minor release (new features)"
            echo "   fix: description      ‚Üí Patch release (bug fixes)"  
            echo "   docs: description     ‚Üí Patch release (documentation)"
            echo "   perf: description     ‚Üí Patch release (performance)"
            echo "   feat!: description    ‚Üí Major release (breaking changes)"
            echo "   fix!: description     ‚Üí Major release (breaking changes)"
            echo ""
            echo "   Non-releasing types: refactor, test, build, ci, chore, style"
            echo ""
            echo "üìñ Resources:"
            echo "   Conventional Commits: https://www.conventionalcommits.org/"
            echo "   Internal Guide: https://syscobt.atlassian.net/wiki/spaces/DSRE/pages/5481759950/How+to+Conventional+commits+for+Git"
            echo ""
            exit 1
          else
            echo "‚úÖ PR VALIDATION PASSED"
            echo ""
            echo "This PR contains $VALID_COMMITS valid conventional commit(s)."
            echo ""
            echo "üéØ RELEASE PREDICTION:"
            echo "   Current version: $(git describe --tags --abbrev=0 2>/dev/null || echo 'v0.0.0')"
            echo "   Expected version: $NEXT_VERSION"
            echo "   $RELEASE_EXPLANATION"
            echo ""
            
            if [ "$RELEASE_TYPE" != "none" ]; then
              echo "üìù Contributing commits:"
              # Show which commits will contribute to the release
              BASE_SHA="${{ github.event.pull_request.base.sha }}"
              HEAD_SHA="${{ github.event.pull_request.head.sha }}"
              git log --no-merges --pretty=format:"%h %s" "$BASE_SHA..$HEAD_SHA" | while read line; do
                commit_message=$(echo "$line" | cut -d' ' -f2-)
                if echo "$commit_message" | grep -qE '^(feat|fix|docs|perf|revert)(\(.+\))?!?:\s'; then
                  if echo "$commit_message" | grep -qE '!:\s'; then
                    echo "   üö® $line (BREAKING)"
                  elif echo "$commit_message" | grep -qE '^feat(\(.+\))?:\s'; then
                    echo "   ‚ú® $line (feature)"
                  elif echo "$commit_message" | grep -qE '^(fix|perf|revert|docs)(\(.+\))?:\s'; then
                    echo "   üîß $line (fix/improvement)"
                  fi
                fi
              done
              echo ""
              
              if [ $((TOTAL_COMMITS - VALID_COMMITS)) -gt 0 ]; then
                echo "‚ö†Ô∏è  Note: $((TOTAL_COMMITS - VALID_COMMITS)) non-conventional commit(s) will be ignored during release"
              fi
            fi
          fi

      - name: Run semantic-release (master branch only)
        if: github.event_name == 'push' && github.ref == 'refs/heads/master'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üöÄ Running semantic-release on master branch..."
          echo ""
          
          # Run semantic-release with comprehensive logging
          npx semantic-release 2>&1 | tee semantic-release.log
          
          # Capture the exit code
          SEMANTIC_RELEASE_EXIT_CODE=${PIPESTATUS[0]}
          
          # Check results and provide appropriate feedback
          if grep -q "There are no relevant changes, so no new version is released" semantic-release.log; then
            echo ""
            echo "‚ÑπÔ∏è No release created - no conventional commits since last release"
            echo ""
            echo "Recent commits analyzed:"
            git log --oneline -10 --pretty=format:"%h %s"
            echo ""
          elif [ $SEMANTIC_RELEASE_EXIT_CODE -ne 0 ]; then
            echo ""
            echo "‚ùå Semantic release failed with exit code $SEMANTIC_RELEASE_EXIT_CODE"
            echo "Check the logs above for details."
            echo ""
            exit $SEMANTIC_RELEASE_EXIT_CODE
          else
            echo ""
            echo "‚úÖ Release completed successfully!"
            
            # Extract and display release info if available
            if grep -q "Published GitHub release" semantic-release.log; then
              RELEASE_URL=$(grep "Published GitHub release" semantic-release.log | sed -n 's/.*Published GitHub release: \(.*\)/\1/p')
              if [ ! -z "$RELEASE_URL" ]; then
                echo "üì¶ Release URL: $RELEASE_URL"
              fi
            fi
            
            if grep -q "Created tag" semantic-release.log; then
              TAG_NAME=$(grep "Created tag" semantic-release.log | sed -n 's/.*Created tag \(.*\)/\1/p')
              if [ ! -z "$TAG_NAME" ]; then
                echo "üè∑Ô∏è Tag: $TAG_NAME"
              fi
            fi
            echo ""
          fi